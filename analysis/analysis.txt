Max Fleischer
mif12

Benchmark times for StringStrand:
dna length = 4,639,221
cutting at enzyme gaattc
-----
Class	                splicee	      recomb	time	appends
-----
StringStrand:	            256	      4,800,471	0.403	1290
StringStrand:	            512	      4,965,591	0.415	1290
StringStrand:	          1,024	      5,295,831	0.455	1290
StringStrand:	          2,048	      5,956,311	0.484	1290
StringStrand:	          4,096	      7,277,271	0.634	1290
StringStrand:	          8,192	      9,919,191	0.814	1290
StringStrand:	         16,384	     15,203,031	1.291	1290
StringStrand:	         32,768	     25,770,711	2.246	1290
StringStrand:	         65,536	     46,906,071	4.336	1290
StringStrand:	        131,072	     89,176,791	9.720	1290
StringStrand:	        262,144	    173,718,231	20.786	1290
StringStrand:	        524,288	    342,801,111	57.936	1290
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space


Benchmark times for StringBuilderStrand:
dna length = 4,639,221
cutting at enzyme gaattc
-----
Class	                splicee	      recomb	time	appends
-----
StringBuilderStrand:	            256	      4,800,471	0.030	1290
StringBuilderStrand:	            512	      4,965,591	0.022	1290
StringBuilderStrand:	          1,024	      5,295,831	0.013	1290
StringBuilderStrand:	          2,048	      5,956,311	0.013	1290
StringBuilderStrand:	          4,096	      7,277,271	0.007	1290
StringBuilderStrand:	          8,192	      9,919,191	0.005	1290
StringBuilderStrand:	         16,384	     15,203,031	0.008	1290
StringBuilderStrand:	         32,768	     25,770,711	0.034	1290
StringBuilderStrand:	         65,536	     46,906,071	0.025	1290
StringBuilderStrand:	        131,072	     89,176,791	0.078	1290
StringBuilderStrand:	        262,144	    173,718,231	0.217	1290
StringBuilderStrand:	        524,288	    342,801,111	0.501	1290
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space


Benchmark times for LinkStrand:
dna length = 4,639,221
cutting at enzyme gaattc
-----
Class	                splicee	      recomb	time	appends
-----
LinkStrand:	            256	      4,800,471	0.025	1290
LinkStrand:	            512	      4,965,591	0.017	1290
LinkStrand:	          1,024	      5,295,831	0.003	1290
LinkStrand:	          2,048	      5,956,311	0.004	1290
LinkStrand:	          4,096	      7,277,271	0.005	1290
LinkStrand:	          8,192	      9,919,191	0.004	1290
LinkStrand:	         16,384	     15,203,031	0.003	1290
LinkStrand:	         32,768	     25,770,711	0.005	1290
LinkStrand:	         65,536	     46,906,071	0.006	1290
LinkStrand:	        131,072	     89,176,791	0.004	1290
LinkStrand:	        262,144	    173,718,231	0.003	1290
LinkStrand:	        524,288	    342,801,111	0.005	1290
LinkStrand:	      1,048,576	    680,966,871	0.006	1290
LinkStrand:	      2,097,152	  1,357,298,391	0.008	1290
LinkStrand:	      4,194,304	  2,709,961,431	0.007	1290
LinkStrand:	      8,388,608	  5,415,287,511	0.006	1290
LinkStrand:	     16,777,216	 10,825,939,671	0.009	1290
LinkStrand:	     33,554,432	 21,647,243,991	0.004	1290
LinkStrand:	     67,108,864	 43,289,852,631	0.005	1290
LinkStrand:	    134,217,728	 86,575,069,911	0.008	1290
LinkStrand:	    268,435,456	173,145,504,471	0.007	1290
LinkStrand:	    536,870,912	346,286,373,591	0.010	1290
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space



Question 1: are the benchmark timings for StringStrand consistent with the explanation
 below that the time to execute cutAndSplice is O(b2S)? 

Note that the value of b is half the number of calls to append since each cut
 (except the first) is modeled by two calls of append in the method cutAndSplice 
 -- see the code. This means that b2 will be constant in the benchmark, but S will vary. 
 
 		Yes, these are consistent with the time to execute cutAndSplice for StringStrand being
 		O(b^2S). b does not vary, but the timings being so much longer than the other timings
 		suggests that there is some form of exponential or O(b^2) growth. 
 		
 		Furthermore, the time varies directly with S. As S is multiplied by roughly 2, (4.9 * 10^6
 		to 9.9 * 10^6), the time doubles (0.415 to 0.814). As S is multiplied by roughly
 		10 (4.8 * 10 ^ 6 to 46.9*10^6), the time is multiplied by 10 (0.403 to 4.3). This is consistent 
 		with a linear relationship between time and S. 

Question 2: are the benchmark timings for StringBuilderStrand consistent with the
 explanation below that the time to execute cutAndSplice is O(bS)? 

Note that the value of b is half the number of calls to append since each cut 
(except the first) is modeled by two calls of append in the method cutAndSplice
 -- see the code. This means that b will be constant in the benchmark, but S will vary. 

		Yes. There is a linear relationship between S and time. As S doubles, time doubles. b
		does not change over the course of the benchmark, but these times are faster than 
		StringStrand times, which means StringBuilderStrand must be more efficient. 
		O(bS) is more efficient than O(b^2S).

Question 3: Explain why the time for LinkStrand does not change much at all over
 all the runs in the benchmark program. Explain why you think memory is 
 exhausted at the specific strand size you see in your timings -- as 
 compared to exhaustion for String and StringBuilder.
 
 		Rather than creating one progressively larger string, LinkStrands can use less memory by each 
 		node having a reference to the same memory location if the nodes have the same info field.
 		This is instead of creating a new space in memory if you want to splice in the same info. 
 		LinkStrand uses the same location in memory for multiple splices, so there is more space in 
 		memory to use. As a result, memory is exhausted at longer splices.
 
Detailed Explanation of cutAndSplice: Time/Memory Complexity
The method cutAndSplice is not a mutator. It starts with a strand of 
DNA and creates a new strand by finding each and every occurrence of 
a restriction enzyme like “gaattc” and replacing this enzyme by a specified 
splicee -- another strand of DNA. If dna represents the strand "cgatcctagatcgg" then the call 
dna.cutAndSplice("gat", "gggtttaaa")
would result in returning a new strand of DNA in which each occurrence 
of the enzyme/strand "gat" in the object dna is replaced by the splice, 
"gggtttaaa" -- as shown in the diagram below where the original strand is shown 
first, with the enzyme "gat" shaded in blue. A new strand of DNA is created and 
returned in which each occurrence of the enzyme "gat" is replaced by the splicee 
"gggtttaaa" as shown below. This diagram illustrates how cutAndSplice works with 
both StringStrand and StringBuilderStrand. Each is a strand of 14 characters in which
 the restriction enzyme "gat" occurs twice, is replaced by "gggtttaaa", resulting in 
 creating and returning a new strand that contains 26 characters.



If the original strand has length N, then the new strand has N + b(S-E) characters 
where b is the number of breaks, or occurrences of the enzyme, S is the length of 
the splicee and E is the length of the enzyme. In the diagram above we have 14 + 2(9-3) which is 26.
 If we assume the splicee is large, as it will be when benchmarking, we can ignore E 
 and this becomes N + bS. 

This expression represents the memory used for the last strand created, not the
 total memory used (see below). The runtime will depend on how long it takes to 
 concatenate two character-sequences. Concatenating two String objects requires 
 creating a new String, so the time to concatenate two strings of length A and B 
 is A + B. For StringBuilder objects, the time to append a String of length B to 
 a StringBuilder of length A is just B, since the StringBuilder is altered so it has 
 length A + B by simply appending B characters. If we append a character sequence of 
 length S and we do this b times, then if we start with an empty strand
  (which isn't the case, because the original strand of DNA is added to via the cutAndSplice method) 
  then we'd have the following sequence of b string concatenations using StringStrand.

S
S + S
S + S + S
…
S + … + S (b times) for the last concatenation

This is (1 + 2 + .. + b)S which is O(b2S). Note that if we use StringBuilderStrand 
objects we'd simply append S a total of b times for an O(bS) runtime for creating 
the new strand.  Of course, searching for the b breaks requires O(N) time for an N-character strand.

LinkStrand Time/Memory

For the same cut/splice diagrammed above, the LinkStrand result is diagrammed below.
Each time the original strand, a single string, is cut/spliced a new node is created. 
The nodes pointing to the splicee can point to the same splicee as shown in the
 diagram for the second and fourth nodes. These represent the first and second 
 occurrences of "gat", respectively.
